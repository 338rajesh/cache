<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>mcmc</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-6544c13f3a64c240a3702504b08109cf.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="monte-carlo-methods-for-uncertainty-quantification" class="level1">
<h1>Monte Carlo Methods for Uncertainty Quantification</h1>
<p>Monte Carlo (MC) methods are a class of computational algorithms that rely on repeated random sampling to obtain numerical results. They are widely used in uncertainty quantification to estimate the expected value, variance, and other statistical properties of a model’s output when the input parameters are uncertain. The basic idea is to:</p>
<ul>
<li>Generate random samples in the input space</li>
<li>Run (deterministic) simulations or calculations for each of these random samples</li>
<li>Summarize the results using statistics (e.g., mean, variance, confidence intervals) to quantify the uncertainty in the output</li>
</ul>
<section id="law-of-large-numbers" class="level2">
<h2 class="anchored" data-anchor-id="law-of-large-numbers">Law of Large Numbers</h2>
<p>MC methods rest on the principle of the law of large numbers, which states that as the number of samples increases, the sample <strong>average converges to the expected value</strong>. This means that with enough samples, we can get an accurate estimate of the uncertainty in our model’s predictions.</p>
<ul>
<li>Strong Law of Large Numbers: The sample average converges to the expected value almost surely (with probability 1).</li>
</ul>
<pre class="math"><code>Pr(\lim_{n \to \infty} \bar{X}_n = \mu) = 1 \quad \text{almost surely}</code></pre>
<ul>
<li>Weak Law of Large Numbers: The probability of <em>the absolute difference between the sample average and the expected</em> value being <em>smaller than any small positive value <span class="math inline">\(\epsilon\)</span></em> approaches 1 as the number of samples goes to infinity.</li>
</ul>
<pre class="math"><code>\lim_{n \to \infty} Pr(|\bar{X}_n - \mu| &lt; \epsilon) = 1 \quad \text{for a small value } \epsilon &gt; 0</code></pre>
<p>Let <span class="math inline">\(X_1, X_2, ..., X_n\)</span> be a sequence of <em>independent and identically distributed (i.i.d.)</em> random variables with expected value <span class="math inline">\(\mu\)</span> and variance <span class="math inline">\(\sigma^2\)</span>. According to LLN, as <span class="math inline">\(n\)</span> increases, the sample average <span class="math inline">\(\bar{X}_n\)</span> converges to <span class="math inline">\(\mu\)</span>.</p>
<pre class="math"><code>\bar{X}_n = \frac{1}{n} \sum_{i=1}^{n} X_i</code></pre>
<p>Variance of the sample average can be used to understand the convergence rate. The following formula shows that the variance of the sample average decreases as the number of samples increases:</p>
<pre class="math"><code>Var(\bar{X}_n) = Var(\frac{1}{n} \sum_{i=1}^{n} X_i) = \frac{1}{n^2} \sum_{i=1}^{n} Var(X_i) = \frac{\sigma^2}{n}</code></pre>
</section>
<section id="monte-carlo-simulation" class="level2">
<h2 class="anchored" data-anchor-id="monte-carlo-simulation">Monte Carlo Simulation</h2>
<p>From law of large numbers:</p>
<pre class="math"><code>\mathbb{E}[X] = \int_{-\infty}^{\infty} x f_{X} (x) dx \approx \frac{1}{N} \sum_{i=1}^{N} X_i</code></pre>
<p>Where <span class="math inline">\(X_i\)</span> are i.i.d. samples drawn from the distribution of <span class="math inline">\(X\)</span>. The accuracy of this approximation improves as <span class="math inline">\(N\)</span> increases, and the variance of the estimate decreases as <span class="math inline">\(\sigma^2 / N\)</span>.</p>
<p><strong>Monte Carlo simulation</strong> is nothing but the process of simulating a large number of realizations of a random variable and then evaluating its average value to estimate the expected value.</p>
<p>Here, the random variable <span class="math inline">\(X\)</span> can be function of another random variable or a vector of random variables. Let <span class="math inline">\(g\)</span> is a function that maps a random variable <span class="math inline">\(X\)</span> to another random variable <span class="math inline">\(Y\)</span>, i.e., <span class="math inline">\(Y = g(X)\)</span>. When <span class="math inline">\(g\)</span> takes a simple analytical form and invertible, we can derive the distribution of <span class="math inline">\(Y\)</span> from the distribution of <span class="math inline">\(X\)</span> using methods like change of variables. However, when <span class="math inline">\(g\)</span> is complex or non-invertible, it becomes difficult to derive the distribution of <span class="math inline">\(Y\)</span> analytically. In such cases, we can use Monte Carlo simulation to estimate the expected value of <span class="math inline">\(Y\)</span>.</p>
<pre class="math"><code>\mathbb{E}[Y] = \mathbb{E}[g(X)] = \int_{-\infty}^{\infty} g(x) f_{X} (x) dx \approx \frac{1}{N} \sum_{i=1}^{N} g(X_i)</code></pre>
<p>Where <span class="math inline">\(X_i\)</span> are i.i.d. samples drawn from the distribution of <span class="math inline">\(X\)</span>. The accuracy of this approximation improves as <span class="math inline">\(N\)</span> increases, and the variance of the estimate decreases as <span class="math inline">\(\sigma^2 / N\)</span>, where <span class="math inline">\(\sigma^2\)</span> is the variance of <span class="math inline">\(g(X)\)</span>.</p>
</section>
<section id="refined-standard-steps" class="level2">
<h2 class="anchored" data-anchor-id="refined-standard-steps">Refined Standard steps</h2>
<p>For any functionor model <span class="math inline">\(g: \mathbb{R}^n \rightarrow Y\)</span>, that takes random variables as input with known probability distribution, one can estimate the expected value of the output distribution using the following Monte Carlo steps:</p>
<ul>
<li>Generate <span class="math inline">\(N\)</span> i.i.d. samples <span class="math inline">\(`\boldsymbol{x}_{1}, \boldsymbol{x}_{2}, ..., \boldsymbol{x}_{N}`\)</span> from the known joint density function <span class="math inline">\(`{f}_{\boldsymbol{X}}(\boldsymbol{x})`\)</span> of the input random vector <span class="math inline">\(`\boldsymbol{X}`\)</span>.</li>
<li>Function/model evaluation: For each sample <span class="math inline">\(\boldsymbol{x}_i\)</span>, compute the corresponding output <span class="math inline">\(y_i = g(\boldsymbol{x}_i)\)</span>. This step involves running the deterministic model or function for each of the generated samples.</li>
<li>Apply Monte Carlo averaging to estimate the expected value of the output distribution:</li>
</ul>
<pre class="math"><code>\mathbb{E}[Y] = \int_{-\infty}^{\infty} y f_{Y} (y) dy \approx \frac{1}{N} \sum_{i=1}^{N} g(\boldsymbol{x}_i)</code></pre>
</section>
<section id="simulating-random-variables" class="level2">
<h2 class="anchored" data-anchor-id="simulating-random-variables">Simulating Random Variables</h2>
<section id="inverse-transform-method" class="level3">
<h3 class="anchored" data-anchor-id="inverse-transform-method">Inverse Transform Method</h3>
</section>
<section id="box-muller-transform" class="level3">
<h3 class="anchored" data-anchor-id="box-muller-transform">Box-Muller Transform</h3>
</section>
<section id="composition-method" class="level3">
<h3 class="anchored" data-anchor-id="composition-method">Composition Method</h3>
</section>
<section id="convolution-method" class="level3">
<h3 class="anchored" data-anchor-id="convolution-method">Convolution Method</h3>
</section>
<section id="acceptance-rejection-method" class="level3">
<h3 class="anchored" data-anchor-id="acceptance-rejection-method">Acceptance-Rejection Method</h3>
</section>
</section>
<section id="random-vectors-and-correlated-random-variables-simulation" class="level2">
<h2 class="anchored" data-anchor-id="random-vectors-and-correlated-random-variables-simulation">Random Vectors and Correlated Random Variables Simulation</h2>
<section id="random-vectors-simulation" class="level3">
<h3 class="anchored" data-anchor-id="random-vectors-simulation">Random Vectors Simulation</h3>
</section>
<section id="cholesky-decomposition" class="level3">
<h3 class="anchored" data-anchor-id="cholesky-decomposition">Cholesky Decomposition</h3>
</section>
</section>
<section id="markov-chain-monte-carlo-methods" class="level2">
<h2 class="anchored" data-anchor-id="markov-chain-monte-carlo-methods">Markov Chain Monte Carlo Methods</h2>
<section id="random-walk-methods" class="level3">
<h3 class="anchored" data-anchor-id="random-walk-methods">Random Walk Methods</h3>
<section id="metropolis-hasting-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="metropolis-hasting-algorithm">Metropolis-Hasting Algorithm</h4>
</section>
<section id="gibbs-sampler" class="level4">
<h4 class="anchored" data-anchor-id="gibbs-sampler">Gibbs Sampler</h4>
</section>
<section id="component-wise-metropolis-hasting-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="component-wise-metropolis-hasting-algorithm">Component-wise Metropolis-Hasting Algorithm</h4>
</section>
</section>
</section>
<section id="variance-reduction-techniques" class="level2">
<h2 class="anchored" data-anchor-id="variance-reduction-techniques">Variance Reduction Techniques</h2>
<section id="control-variates" class="level3">
<h3 class="anchored" data-anchor-id="control-variates">Control Variates</h3>
</section>
<section id="importance-sampling" class="level3">
<h3 class="anchored" data-anchor-id="importance-sampling">Importance Sampling</h3>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>